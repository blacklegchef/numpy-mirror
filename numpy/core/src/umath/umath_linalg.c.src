/* -*- c -*- */

/*
 *****************************************************************************
 **                            INCLUDES                                     **
 *****************************************************************************
 */
#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include "Python.h"
#include "numpy/arrayobject.h"
#include "numpy/ufuncobject.h"

#include "npy_pycompat.h"

#include "npy_config.h"

#ifndef CBLAS_HEADER
#define CBLAS_HEADER "cblas.h"
#endif

#include CBLAS_HEADER

#include <stddef.h>
#include <stdio.h>

/*
 *****************************************************************************
 **                      Some handy constants                               **
 *****************************************************************************
 */

static const char* umath_linalg_module_name =  "umath_linalg";

static const float s_one = 1.0f;
static const float s_zero = 0.0f;
static const double d_one = 1.0;
static const double d_zero = 0.0;
static const float c_one[2] = { 1.0f, 0.0f };
static const float c_zero[2] = { 0.0f, 0.0f };
static const double z_one[2] = { 1.0, 0.0 };
static const double z_zero[2] = { 0.0, 0.0 };


/*
 *****************************************************************************
 **               Structs used for data rearrangement                       **
 *****************************************************************************
 */


/* this struct contains information about how to linearize in a local buffer
   a matrix so that it can be used by blas functions.
   All strides are specified in number of elements (similar to what blas expects)

   dst_row_strides: number of elements between different row. Matrix is considered
                    row-major
   dst_column_strides: number of elements between differnt columns in the
                    destination buffer
   rows: number of rows of the matrix
   columns: number of columns of the matrix
   src_row_strides: strides needed to access the next row in the source matrix
   src_column_strides: strides needed to access the next column in the source
                       matrix
 */
typedef struct linearize_data_struct
{
  size_t     rows;
  size_t     columns;
  ptrdiff_t  row_strides;
  ptrdiff_t  column_strides;
} LINEARIZE_DATA_t;

typedef struct gemm_params_struct
{
    int   trans[2]; // use transpose
    int   m,n,k; // note there is a relationship between this and lin_data rows
                 // & columns but the actual relationship is dependent on trans.
    int   strides[3]; // strides to use in gemm call
    void *buff[3];  // memory buff for the operand to use in blas call
    LINEARIZE_DATA_t lin_data[3];
} GEMM_PARAMS_t;

static inline void
init_gemm_params(GEMM_PARAMS_t *params, size_t m, size_t n, size_t k)
{
    int i;
    for (i = 0; i < sizeof(params->trans)/sizeof(params->trans[0]); i++)
        params->trans[i] = CblasNoTrans;

    params->m = (int) m;
    params->n = (int) n;
    params->k = (int) k;

    // this should be initialized later when it is known whether we are doing it
    // in-place or in a tmp buffer.
    for (i = 0 ; i < sizeof(params->strides)/sizeof(params->strides[0]); i++)
       params->strides[i] = 0;
}

static inline void
init_linearize_data(LINEARIZE_DATA_t *lin_data, 
                    int rows, 
                    int columns, 
                    ptrdiff_t row_strides, 
                    ptrdiff_t column_strides)
{
    lin_data->rows = rows;
    lin_data->columns = columns;
    lin_data->row_strides = row_strides;
    lin_data->column_strides = column_strides;
}

#if 0
static void
dump_linearize_data_params(const char* name, const LINEARIZE_DATA_t* params)
{
    printf("\n\t%s rows: %d columns: %d"
           "\n\t\trow_strides: %d column_strides: %d"
           "\n", name, params->rows, params->columns,
           params->row_strides, params->column_strides);
}

static void
dump_gemm_params(const GEMM_PARAMS_t* params)
{
    printf("\n\ngemm_params: src1: %s transposed src2: %s transposed"
           "\n\tM: %d N: %d K: %d",
           params->trans[0] == CblasNoTrans? "NOT" : "",
           params->trans[1] == CblasNoTrans? "NOT" : "",
           params->m, params->n, params->k);
    dump_linearize_data_params("src1", &params->lin_data[0]);
    dump_linearize_data_params("src2", &params->lin_data[1]);
    dump_linearize_data_params("dst", &params->lin_data[2]);
}
#endif


/*
 *****************************************************************************
 **                            Basics                                       **
 *****************************************************************************
 */

#define INIT_OUTER_LOOP_1       \
    npy_intp dN = *dimensions++;\
    npy_intp N_;                \
    npy_intp s0 = *steps++;

#define INIT_OUTER_LOOP_2       \
    INIT_OUTER_LOOP_1           \
    npy_intp s1 = *steps++;

#define INIT_OUTER_LOOP_3       \
    INIT_OUTER_LOOP_2           \
    npy_intp s2 = *steps++;

#define INIT_OUTER_LOOP_4       \
    INIT_OUTER_LOOP_3           \
    npy_intp s3 = *steps++;

#define BEGIN_OUTER_LOOP_3      \
    for (N_ = 0; N_ < dN; N_++, args[0] += s0, args[1] += s1, args[2] += s2) {

#define BEGIN_OUTER_LOOP_4      \
    for (N_ = 0; N_ < dN; N_++, args[0] += s0, args[1] += s1, args[2] += s2, args[3] += s3) {

#define END_OUTER_LOOP  }


/*
 *****************************************************************************
 **                             UFUNC LOOPS                                 **
 *****************************************************************************
 */

/**begin repeat

   #TYPE=FLOAT,DOUBLE#
   #typ=npy_float, npy_double#
   #cblas_dot=cblas_sdot, cblas_ddot# 

*/

/*
 *  This implements the function
 *        out[n] = sum_i { in1[n, i] * in2[n, i] }.
 */

static inline void 
@TYPE@_inner1d_blas(char **args, npy_intp* dimensions, npy_intp * steps)
{
    INIT_OUTER_LOOP_3
    const size_t sot = sizeof(@typ@);

    int dim = (int) dimensions[0];
    int is1 = (int)(steps[0]/sot), is2 = (int)(steps[1]/sot);

    BEGIN_OUTER_LOOP_3
        @typ@ * ip1 = (@typ@*)args[0], *ip2 = (@typ@*)args[1];
        *(@typ@*)(args[2]) = @cblas_dot@(dim, ip1, is1, ip2, is2);
    END_OUTER_LOOP
}

static inline void 
@TYPE@_inner1d_std(char **args, npy_intp* dimensions, npy_intp * steps)
{
    INIT_OUTER_LOOP_3
    npy_intp di = dimensions[0];
    npy_intp i;
    npy_intp is1=steps[0], is2=steps[1];
    BEGIN_OUTER_LOOP_3
        char *ip1=args[0], *ip2=args[1], *op=args[2];
    @typ@ sum = 0;
        for (i = 0; i < di; i++) {
            sum += (*(@typ@ *)ip1) * (*(@typ@ *)ip2);
            ip1 += is1;
            ip2 += is2;
        }
        *(@typ@ *)op = sum;
    END_OUTER_LOOP
}

static void
@TYPE@_inner1d(char **args, npy_intp *dimensions, npy_intp *steps,
               void *NPY_UNUSED(func))
{
    const size_t sot = sizeof(@typ@);
    /* 
     * use blas if the stride is a multiple of datatype size in the inputs
     * it should be the common case 
     */

    if ((0 == (steps[3] % sot)) &&
        (0 == (steps[4] % sot))) {
        /* use blas */
        @TYPE@_inner1d_blas(args, dimensions, steps);
    } else {
        /* use standard version */
        @TYPE@_inner1d_std(args, dimensions, steps);
    }
}

/**end repeat**/

/**begin repeat

   #TYPE=FLOAT,DOUBLE#
   #typ=npy_float, npy_double# 

*/

/*
 *  This implements the function
 *        out[n] = sum_i { in1[n, i] * in2[n, i] * in3[n, i] }.
 */

static void
@TYPE@_innerwt(char **args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_4
    npy_intp di = dimensions[0];
    npy_intp i;
    npy_intp is1=steps[0], is2=steps[1], is3=steps[2];
    BEGIN_OUTER_LOOP_4
        char *ip1=args[0], *ip2=args[1], *ip3=args[2], *op=args[3];
        @typ@ sum = 0;
        for (i = 0; i < di; i++) {
            sum += (*(@typ@ *)ip1) * (*(@typ@ *)ip2) * (*(@typ@ *)ip3);
            ip1 += is1;
            ip2 += is2;
            ip3 += is3;
        }
        *(@typ@ *)op = sum;
    END_OUTER_LOOP
}

/**end repeat**/


/* -------------------------------------------------------------------------- */
/* rearranging of 2D matrices using blas */

/**begin repeat

    #TYPE=FLOAT,DOUBLE,CFLOAT,CDOUBLE#
    #typ=npy_float,npy_double,npy_cfloat,npy_cdouble# 
    #cblas_type=s,d,c,z#
 */
static inline @typ@ *
linearize_@TYPE@_matrix(@typ@ *dst, @typ@ *src,const LINEARIZE_DATA_t* data)
{
    if (dst) {
        int i;
        @typ@* rv = dst;
        for (i=0; i< data->rows; i++) {
            cblas_@cblas_type@copy(data->columns,
                                   src, data->column_strides/sizeof(@typ@),
                                   dst, 1);
            src += data->row_strides/sizeof(@typ@);
            dst += data->columns;
        } 
        return rv;
    } else {
        return src;
    }
}

static inline @typ@ *
delinearize_@TYPE@_matrix(@typ@ *dst, @typ@ *src,const LINEARIZE_DATA_t* data)
{
    if (src) {
        int i;
        @typ@ *rv = src;
        for (i=0; i < data->rows; i++) {
            cblas_@cblas_type@copy(data->columns,
                                   src, 1,
                                   dst, data->column_strides/sizeof(@typ@));
            src += data->columns;
            dst += data->row_strides/sizeof(@typ@);
        }

        return rv;
    } else {
        return src;
    }
}

/**end repeat**/

/**begin repeat

   #TYPE=FLOAT,DOUBLE,CFLOAT,CDOUBLE#
   #typ=npy_float,npy_double,npy_cfloat,npy_cdouble#
   #cblas_type=s,d,c,z#
*/

/*
 *  This implements the function
 *        out[k, m, p] = sum_n { in1[k, m, n] * in2[k, n, p] }.
 */

static inline void
@TYPE@_matrix_multiply_blas_straight(char **args,
                                     npy_intp *dimensions,
                                     npy_intp *steps,
                                     GEMM_PARAMS_t* params)

{
    /* 
     * everything is setup in a way that makes things work. BLAS gemm can be
     * be called without rearranging nor using weird stuff, as matrices are
     * in the expected way in memory.
     * This is just a loop calling blas.
     */
    INIT_OUTER_LOOP_3

    BEGIN_OUTER_LOOP_3
        /* just call the appropriate multiply and update pointers */
        @typ@ *src1 = linearize_@TYPE@_matrix((@typ@ *) params->buff[0], (@typ@ *) args[0], &params->lin_data[0]);
        @typ@ *src2 = linearize_@TYPE@_matrix((@typ@ *) params->buff[1], (@typ@ *) args[1], &params->lin_data[1]);
        @typ@ *dst = params->buff[2] ? params->buff[2] : (@typ@ *) args[2];

        /* linearize source operands if needed */
        cblas_@cblas_type@gemm(CblasRowMajor, params->trans[0], params->trans[1],
                               params->m, params->n, params->k, 
                               @cblas_type@_one, // alpha
                               src1, params->strides[0],
                               src2, params->strides[1],
                               @cblas_type@_zero, // beta
                               dst, params->strides[2]
                              );
        
	delinearize_@TYPE@_matrix((@typ@ *)args[2], (@typ@ *)params->buff[2], &params->lin_data[2]);
    END_OUTER_LOOP
}


static void
@TYPE@_matrix_multiply(char **args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    GEMM_PARAMS_t gemm_params;
    int i;
    size_t sot = sizeof(@typ@);
    uint8_t* mem_buffer = NULL;
    size_t buff_size[3], total_buff_size, offset;

    size_t m, k, n;
    m = (size_t) dimensions[1];
    k = (size_t) dimensions[2];
    n = (size_t) dimensions[3];

    init_gemm_params(&gemm_params, m, n, k);
    init_linearize_data(&gemm_params.lin_data[0], m, k, steps[3], steps[4]);
    init_linearize_data(&gemm_params.lin_data[1], k, n, steps[5], steps[6]);
    init_linearize_data(&gemm_params.lin_data[2], m, n, steps[7], steps[8]);
    
    /* compute size and reserve if needed local buffers */
    for (i = 0; i < 3; i++) {
        if (gemm_params.lin_data[i].column_strides == sot) {
            buff_size[i] = 0;
            gemm_params.strides[i] = steps[3+i*2] / sot;
        } else {
            buff_size[i] = gemm_params.lin_data[i].rows * gemm_params.lin_data[i].columns * sot;
            gemm_params.strides[i] = gemm_params.lin_data[i].columns;
        }
    }

    total_buff_size = buff_size[0] + buff_size[1] + buff_size[2];
    if (total_buff_size) {
        mem_buffer = (uint8_t*)malloc(total_buff_size);
    }

    offset = 0;
    for (i=0; i<3; i++) {
        if (buff_size[i] == 0) {
            /* inplace */ 
            gemm_params.buff[i] = NULL;
        } else {
            /* an intermediate copy will be needed */
            gemm_params.buff[i] = (void*)(mem_buffer + offset);
            offset += buff_size[i];
        }
    }

    @TYPE@_matrix_multiply_blas_straight(args, dimensions, steps, &gemm_params);

    free(mem_buffer);
}

/**end repeat**/

/*  The following lines were generated using a slightly modified
    version of code_generators/generate_umath.py and adding these
    lines to defdict:

defdict = {
'inner1d' :
    Ufunc(2, 1, None_,
        r'''inner on the last dimension and broadcast on the rest \n"
        "     \"(i),(i)->()\" \n''',
          TD('ld'),
          ),
'innerwt' :
    Ufunc(3, 1, None_,
          r'''inner1d with a weight argument \n"
          "     \"(i),(i),(i)->()\" \n''',
          TD('ld'),
          ),
}

*/

char *inner1d_signature = "(i),(i)->()";
static PyUFuncGenericFunction inner1d_functions[] = { 
    FLOAT_inner1d, 
    DOUBLE_inner1d
 };
static void * inner1d_data[] = { 
    (void *)NULL, 
    (void *) NULL
};
static char inner1d_signatures[] = { 
    NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, 
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE
};

char *innerwt_signature = "(i),(i),(i)->()";
static PyUFuncGenericFunction innerwt_functions[] = { 
    FLOAT_innerwt, 
    DOUBLE_innerwt 
};
static void * innerwt_data[] = { 
    (void *)NULL, 
    (void *)NULL 
};
static char innerwt_signatures[] = {
    NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE
 };


/* note: using blas gemm nomenclature for m, k and n */
char *matrix_multiply_signature = "(m,k),(k,n)->(m,n)";
static PyUFuncGenericFunction matrix_multiply_functions[] = { 
    FLOAT_matrix_multiply, 
    DOUBLE_matrix_multiply,
    CFLOAT_matrix_multiply,
    CDOUBLE_matrix_multiply
};
static void *matrix_multiply_data[] = {
    (void *)NULL, 
    (void *)NULL, 
    (void *)NULL,
    (void *)NULL,
};
static char matrix_multiply_signatures[] = { 
    NPY_FLOAT, NPY_FLOAT, NPY_FLOAT,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
    NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT,
    NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE
};

static void
addUfuncs(PyObject *dictionary) {
    PyObject *f;

    f = PyUFunc_FromFuncAndDataAndSignature(inner1d_functions, inner1d_data, inner1d_signatures, 2,
                                    2, 1, PyUFunc_None, "inner1d",
                                    "inner on the last dimension and broadcast on the rest \n"\
                                    "     \"(i),(i)->()\" \n",
                                    0, inner1d_signature);
    PyDict_SetItemString(dictionary, "inner1d", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndDataAndSignature(innerwt_functions, innerwt_data, innerwt_signatures, 2,
                                    3, 1, PyUFunc_None, "innerwt",
                                    "inner1d with a weight argument \n"\
                                    "     \"(i),(i),(i)->()\" \n",
                                    0, innerwt_signature);
    PyDict_SetItemString(dictionary, "innerwt", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndDataAndSignature(matrix_multiply_functions,
                                    matrix_multiply_data, matrix_multiply_signatures,
                                    3, 2, 1, PyUFunc_None, "matrix_multiply",
                                    "matrix multiplication on last two dimensions \n"\
                                    "     \"(m,n),(n,p)->(m,p)\" \n",
                                    0, matrix_multiply_signature);
    PyDict_SetItemString(dictionary, "matrix_multiply", f);
    Py_DECREF(f);
}

/*
    End of auto-generated code.
*/

static PyObject *
UMath_Tests_test_signature(PyObject *NPY_UNUSED(dummy), PyObject *args)
{
    int nin, nout;
    PyObject *signature, *sig_str;
    PyObject *f;
    int core_enabled;

    if (!PyArg_ParseTuple(args, "iiO", &nin, &nout, &signature)) return NULL;


    if (PyString_Check(signature)) {
        sig_str = signature;
    } else if (PyUnicode_Check(signature)) {
        sig_str = PyUnicode_AsUTF8String(signature);
    } else {
        PyErr_SetString(PyExc_ValueError, "signature should be a string");
        return NULL;
    }

    f = PyUFunc_FromFuncAndDataAndSignature(NULL, NULL, NULL,
        0, nin, nout, PyUFunc_None, "no name",
        "doc:none",
        1, PyString_AS_STRING(sig_str));
    if (sig_str != signature) {
        Py_DECREF(sig_str);
    }
    if (f == NULL) return NULL;
    core_enabled = ((PyUFuncObject*)f)->core_enabled;
    Py_DECREF(f);
    return Py_BuildValue("i", core_enabled);
}

static PyMethodDef UMath_TestsMethods[] = {
    {"test_signature",  UMath_Tests_test_signature, METH_VARARGS,
     "Test signature parsing of ufunc. \n"
     "Arguments: nin nout signature \n"
     "If fails, it returns NULL. Otherwise it will returns 0 for scalar ufunc "
     "and 1 for generalized ufunc. \n",
     },
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

#if defined(NPY_PY3K)
static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        umath_linalg_module_name,
        NULL,
        -1,
        UMath_TestsMethods,
        NULL,
        NULL,
        NULL,
        NULL
};
#endif

#if defined(NPY_PY3K)
#define RETVAL m
PyObject *PyInit_umath_linalg(void)
#else
#define RETVAL
PyMODINIT_FUNC
initumath_linalg(void)
#endif
{
    PyObject *m;
    PyObject *d;
    PyObject *version;

#if defined(NPY_PY3K)
    m = PyModule_Create(&moduledef);
#else
    m = Py_InitModule(umath_linalg_module_name, UMath_TestsMethods);
#endif
    if (m == NULL)
        return RETVAL;

    import_array();
    import_ufunc();

    d = PyModule_GetDict(m);

    version = PyString_FromString("0.1");
    PyDict_SetItemString(d, "__version__", version);
    Py_DECREF(version);

    /* Load the ufunc operators into the module's namespace */
    addUfuncs(d);

    if (PyErr_Occurred()) {
        PyErr_SetString(PyExc_RuntimeError,
                        "cannot load umath_tests module.");
    }

    return RETVAL;
}
