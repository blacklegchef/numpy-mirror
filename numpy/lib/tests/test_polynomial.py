from __future__ import division, absolute_import, print_function

'''
>>> p = np.poly1d([1.,2,3])
>>> p
poly1d([ 1.,  2.,  3.])
>>> print(p)
   2
1 x + 2 x + 3
>>> q = np.poly1d([3.,2,1])
>>> q
poly1d([ 3.,  2.,  1.])
>>> print(q)
   2
3 x + 2 x + 1
>>> print(np.poly1d([1.89999+2j, -3j, -5.12345678, 2+1j]))
            3      2
(1.9 + 2j) x - 3j x - 5.123 x + (2 + 1j)
>>> print(np.poly1d([-3, -2, -1]))
    2
-3 x - 2 x - 1

>>> p(0)
3.0
>>> p(5)
38.0
>>> q(0)
1.0
>>> q(5)
86.0

>>> p * q
poly1d([  3.,   8.,  14.,   8.,   3.])
>>> p / q
(poly1d([ 0.33333333]), poly1d([ 1.33333333,  2.66666667]))
>>> p + q
poly1d([ 4.,  4.,  4.])
>>> p - q
poly1d([-2.,  0.,  2.])
>>> p ** 4
poly1d([   1.,    8.,   36.,  104.,  214.,  312.,  324.,  216.,   81.])

>>> p(q)
poly1d([  9.,  12.,  16.,   8.,   6.])
>>> q(p)
poly1d([  3.,  12.,  32.,  40.,  34.])

>>> np.asarray(p)
array([ 1.,  2.,  3.])
>>> len(p)
2

>>> p[0], p[1], p[2], p[3]
(3.0, 2.0, 1.0, 0)

>>> p.integ()
poly1d([ 0.33333333,  1.        ,  3.        ,  0.        ])
>>> p.integ(1)
poly1d([ 0.33333333,  1.        ,  3.        ,  0.        ])
>>> p.integ(5)
poly1d([ 0.00039683,  0.00277778,  0.025     ,  0.        ,  0.        ,
        0.        ,  0.        ,  0.        ])
>>> p.deriv()
poly1d([ 2.,  2.])
>>> p.deriv(2)
poly1d([ 2.])

>>> q = np.poly1d([1.,2,3], variable='y')
>>> print(q)
   2
1 y + 2 y + 3
>>> q = np.poly1d([1.,2,3], variable='lambda')
>>> print(q)
        2
1 lambda + 2 lambda + 3

>>> np.polydiv(np.poly1d([1,0,-1]), np.poly1d([1,1]))
(poly1d([ 1., -1.]), poly1d([ 0.]))

'''
import numpy as np
from numpy.testing import (
    run_module_suite, TestCase, assert_, assert_equal, assert_array_equal,
    assert_almost_equal, assert_array_almost_equal, rundocs
    )


class TestDocs(TestCase):
    def test_doctests(self):
        return rundocs()

    def test_poly(self):
        assert_array_almost_equal(np.poly([3, -np.sqrt(2), np.sqrt(2)]),
                                  [1, -3, -2, 6])
        
        # From matlab docs
        A = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
        assert_array_almost_equal(np.poly(A), [1, -6, -72, -27])

        # Should produce real output for perfect conjugates
        assert_(np.isrealobj(np.poly([+1.082j, +2.613j, -2.613j, -1.082j])))
        assert_(np.isrealobj(np.poly([0+1j, -0+-1j, 1+2j, 1-2j, 1.+3.5j, 1-3.5j])))
        assert_(np.isrealobj(np.poly([1j, -1j, 1+2j, 1-2j, 1+3j, 1-3.j])))
        assert_(np.isrealobj(np.poly([1j, -1j, 1+2j, 1-2j])))
        assert_(np.isrealobj(np.poly([1j, -1j, 2j, -2j])))
        assert_(np.isrealobj(np.poly([1j, -1j])))
        assert_(np.isrealobj(np.poly([1, -1])))
        
        assert_(np.iscomplexobj(np.poly([1j, -1.0000001j])))

        a = np.array([ 0.156954782163288+0.984270709753367j,
        0.622215082237431+0.815403412551784j,
        0.192767508171407+0.025782783400578j,
        0.185259804856739+0.062797902506984j,
        0.642062232914462+0.258301456097768j,
        0.554216030989744+0.563355351870913j,
        0.257546073507044+0.525462181113635j,
        0.069480950067410+0.929049150512649j,
        0.096319535923967+0.157777020606244j,
        0.708090004255965+0.844669553809902j,
        0.425935775597273+0.125078838218321j,
        0.970152325957828+0.851990066251973j,
        0.704876672261560+0.193300382687057j,
        0.973090791069053+0.373260711231715j,
        0.858196147177131+0.05834145118111j ,
        0.219200867770377+0.841215110962817j,
        0.262803798327004+0.350643402581111j,
        0.695129112984574+0.838433416963582j,
        0.492312071206577+0.568692426000207j,
        0.461596720878441+0.939374973294176j,
        0.875862628133633+0.387188834096265j,
        0.510155097370032+0.086507519082896j,
        0.416241737182592+0.997111268069588j,
        0.437687604607545+0.338506697660151j,
        0.521443013907779+0.867476314513278j,
        0.430452365593011+0.37031608091577j ,
        0.345316632952483+0.548675748644057j,
        0.149523073174576+0.928825871510194j,
        0.923082836345975+0.437036121992853j,
        0.833612375039695+0.683069897188595j,
        0.139074221945298+0.833315145348817j,
        0.653499684833185+0.351573042621427j,
        0.461341447535269+0.925980448573019j,
        0.055277550126714+0.533775159709293j,
        0.270768043029381+0.010703056622904j,
        0.482823304062645+0.08952461265093j ,
        0.385633251633276+0.471519033804927j,
        0.720444297565953+0.115168361978791j,
        0.901325096506279+0.573680608616877j,
        0.959391049112433+0.693872340885839j,
        0.875681825163325+0.568590792955772j,
        0.342690505279819+0.157893904699271j,
        0.464525179914033+0.29171018650294j ,
        0.009793808914706+0.561574572890755j,
        0.728374526873344+0.766958583319351j,
        0.236256527104613+0.398956198854611j,
        0.005192803665847+0.6582409070444j  ,
        0.500947297517811+0.986725666390376j,
        0.122809093777905+0.718680008979424j,
        0.526136583175024+0.623303763302004j,
        0.330389021549133+0.453395938203371j,
        0.077737539510244+0.247246328523751j,
        0.975408285543645+0.107323424042245j,
        0.003108270882599+0.887002919906503j,
        0.705369913247720+0.727872932569583j,
        0.633198660668698+0.638479991067479j,
        0.549251188569645+0.805780727887373j,
        0.265913392155735+0.780589896981667j,
        0.886221583652843+0.354483251386333j,
        0.075962413516947+0.74149612838474j ,
        0.387765278689023+0.261920931194769j,
        0.948020419648345+0.962386254625887j,
        0.171825523058385+0.627697322385636j,
        0.773639395361929+0.560492952470529j,
        0.939715690837345+0.905583974484841j,
        0.435045495931129+0.094656944697808j,
        0.762649213991775+0.449112026839121j,
        0.213651264630881+0.811270873115497j,
        0.570908734237865+0.658844605819891j,
        0.219391840755125+0.495267594812611j,
        0.262407487010337+0.040859801611494j,
        0.442188925584075+0.152902944310853j,
        0.461651269744638+0.656796707213587j,
        0.664031310363019+0.109070794733818j,
        0.771690766165916+0.30133668510443j ,
        0.920953990465468+0.805475073423507j,
        0.573345189066715+0.150257996561483j,
        0.188075887121730+0.949400965438739j,
        0.657412049911476+0.671647766047969j,
        0.457617239769180+0.524527009214878j,
        0.171132581309313+0.863116500343149j,
        0.684223873158406+0.020730339332808j,
        0.689288538461901+0.853005338506492j,
        0.655100897151547+0.738842295189445j,
        0.469288725720117+0.169269913506413j,
        0.727009355656050+0.143819575672136j,
        0.629418760068722+0.903341905093775j,
        0.721343748466731+0.530360235423122j,
        0.175701721256605+0.116376710227018j,
        0.525170376501935+0.296511653195648j,
        0.964998457578896+0.329699663252158j,
        0.640601603201311+0.462798516244823j,
        0.877865654950912+0.654173127841309j,
        0.729729383013391+0.56291800466453j ,
        0.018630332051044+0.821498382381245j,
        0.131727707997140+0.530713631823519j,
        0.187791574003037+0.626722638953091j,
        0.399902516540311+0.950780374305921j,
        0.526632360878467+0.467303482757566j,
        0.296258070015251+0.977206756817445j])
        assert_(np.isrealobj(np.poly(np.concatenate((a, np.conjugate(a))))))

    def test_roots(self):
        assert_array_equal(np.roots([1, 0, 0]), [0, 0])

    def test_str_leading_zeros(self):
        p = np.poly1d([4, 3, 2, 1])
        p[3] = 0
        assert_equal(str(p),
                     "   2\n"
                     "3 x + 2 x + 1")

        p = np.poly1d([1, 2])
        p[0] = 0
        p[1] = 0
        assert_equal(str(p), " \n0")

    def test_polyfit(self):
        c = np.array([3., 2., 1.])
        x = np.linspace(0, 2, 7)
        y = np.polyval(c, x)
        err = [1, -1, 1, -1, 1, -1, 1]
        weights = np.arange(8, 1, -1)**2/7.0

        # check 1D case
        m, cov = np.polyfit(x, y+err, 2, cov=True)
        est = [3.8571, 0.2857, 1.619]
        assert_almost_equal(est, m, decimal=4)
        val0 = [[2.9388, -5.8776, 1.6327],
                [-5.8776, 12.7347, -4.2449],
                [1.6327, -4.2449, 2.3220]]
        assert_almost_equal(val0, cov, decimal=4)

        m2, cov2 = np.polyfit(x, y+err, 2, w=weights, cov=True)
        assert_almost_equal([4.8927, -1.0177, 1.7768], m2, decimal=4)
        val = [[8.7929, -10.0103, 0.9756],
               [-10.0103, 13.6134, -1.8178],
               [0.9756, -1.8178, 0.6674]]
        assert_almost_equal(val, cov2, decimal=4)

        # check 2D (n,1) case
        y = y[:, np.newaxis]
        c = c[:, np.newaxis]
        assert_almost_equal(c, np.polyfit(x, y, 2))
        # check 2D (n,2) case
        yy = np.concatenate((y, y), axis=1)
        cc = np.concatenate((c, c), axis=1)
        assert_almost_equal(cc, np.polyfit(x, yy, 2))

        m, cov = np.polyfit(x, yy + np.array(err)[:, np.newaxis], 2, cov=True)
        assert_almost_equal(est, m[:, 0], decimal=4)
        assert_almost_equal(est, m[:, 1], decimal=4)
        assert_almost_equal(val0, cov[:, :, 0], decimal=4)
        assert_almost_equal(val0, cov[:, :, 1], decimal=4)

    def test_objects(self):
        from decimal import Decimal
        p = np.poly1d([Decimal('4.0'), Decimal('3.0'), Decimal('2.0')])
        p2 = p * Decimal('1.333333333333333')
        assert_(p2[1] == Decimal("3.9999999999999990"))
        p2 = p.deriv()
        assert_(p2[1] == Decimal('8.0'))
        p2 = p.integ()
        assert_(p2[3] == Decimal("1.333333333333333333333333333"))
        assert_(p2[2] == Decimal('1.5'))
        assert_(np.issubdtype(p2.coeffs.dtype, np.object_))
        p = np.poly([Decimal(1), Decimal(2)])
        assert_equal(np.poly([Decimal(1), Decimal(2)]),
                     [1, Decimal(-3), Decimal(2)])

    def test_complex(self):
        p = np.poly1d([3j, 2j, 1j])
        p2 = p.integ()
        assert_((p2.coeffs == [1j, 1j, 1j, 0]).all())
        p2 = p.deriv()
        assert_((p2.coeffs == [6j, 2j]).all())

    def test_integ_coeffs(self):
        p = np.poly1d([3, 2, 1])
        p2 = p.integ(3, k=[9, 7, 6])
        assert_(
            (p2.coeffs == [1/4./5., 1/3./4., 1/2./3., 9/1./2., 7, 6]).all())

    def test_zero_dims(self):
        try:
            np.poly(np.zeros((0, 0)))
        except ValueError:
            pass

    def test_poly_int_overflow(self):
        """
        Regression test for gh-5096.
        """
        v = np.arange(1, 21)
        assert_almost_equal(np.poly(v), np.poly(np.diag(v)))


if __name__ == "__main__":
    run_module_suite()
